<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Boost.Locale: Character Set Conversions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../style/section-basic.css">
</head>
<body>
<div id="boost-common-heading-doc">
    <div class="heading-inner">
        <div class="heading-placard"></div>

        <h1 class="heading-title">
            <a href="http://www.boost.org/">
                <img src="../style/space.png" alt= "Boost C++ Libraries" class="heading-logo" />
                <span class="heading-boost">Boost</span>
                <span class="heading-cpplibraries">C++ Libraries</span>
            </a>
        </h1>

        <p class="heading-quote">

            <q>...one of the most highly
            regarded and expertly designed C++ library projects in the
            world.</q> 
            
            <span class="heading-attribution">&mdash; <a href=
            "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
            "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
            Alexandrescu</a>, <a href=
            "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
            Coding Standards</a></span>
        </p>
    </div>
</div>

<div id="boost-common-heading-doc-spacer"></div> 
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">Boost.Locale</a>      </li>
      <li><a class="el" href="using_boost_locale.html">Using Boost.Locale</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Character Set Conversions </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="codecvt"></a>
Convenience Interface</h2>
<p>Boost.Locale provides to_utf, from_utf and <a class="el" href="group__codepage.html#ga2de4d9d38004e5d7146abf2bd6a3df0b">utf_to_utf</a> functions in the <code>boost::locale::conv</code> namespace. They are simple and convenient functions to convert a string to and from UTF-8/16/32 strings and strings using other encodings.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">std::string utf8_string = to_utf&lt;char&gt;(latin1_string,<span class="stringliteral">&quot;Latin1&quot;</span>);
std::wstring wide_string = to_utf&lt;wchar_t&gt;(latin1_string,<span class="stringliteral">&quot;Latin1&quot;</span>);
std::string latin1_string = from_utf(wide_string,<span class="stringliteral">&quot;Latin1&quot;</span>);
std::string utf8_string2 = utf_to_utf&lt;char&gt;(wide_string);
</pre></div><p>This function may use an explicit encoding name like "Latin1" or "ISO-8859-8", or use std::locale as a parameter to fetch this information from it. It also receives a policy parameter that tells it how to behave if the conversion can't be performed (i.e. an illegal or unsupported character is found). By default this function skips all illegal characters and tries to do the best it can, however, it is possible ask it to throw a <a class="el" href="classboost_1_1locale_1_1conv_1_1conversion__error.html">conversion_error</a> exception by passing the <code>stop</code> flag to it:</p>
<div class="fragment"><pre class="fragment">std::wstring s=to_utf&lt;wchar_t&gt;(<span class="stringliteral">&quot;\xFF\xFF&quot;</span>,<span class="stringliteral">&quot;UTF-8&quot;</span>,stop); 
<span class="comment">// Throws because this string is illegal in UTF-8</span>
</pre></div><h2><a class="anchor" id="codecvt_codecvt"></a>
std::codecvt facet</h2>
<p>Boost.Locale provides stream codepage conversion facets based on the <code>std::codecvt</code> facet. This allows conversion between wide-character encodings and 8-bit encodings like UTF-8, ISO-8859 or Shift-JIS.</p>
<p>Most of compilers provide such facets, but:</p>
<ul>
<li>Under Windows MSVC does not support UTF-8 encodings at all.</li>
<li>Under Linux the encodings are supported only if the required locales are generated. For example it may be impossible to create a <code>he_IL.CP1255</code> locale even when the <code>he_IL</code> locale is available.</li>
</ul>
<p>Thus Boost.Locale provides an option to generate code-page conversion facets for use with Boost.Iostreams filters or <code>std::wfstream</code>. For example:</p>
<div class="fragment"><pre class="fragment">    std::locale loc= generator().generate(<span class="stringliteral">&quot;he_IL.UTF-8&quot;</span>);
    std::wofstream file.
    file.imbue(loc);
    file.open(<span class="stringliteral">&quot;hello.txt&quot;</span>);
    file &lt;&lt; L<span class="stringliteral">&quot;שלום!&quot;</span> &lt;&lt; endl;
</pre></div><p>Would create a file <code>hello.txt</code> encoded as UTF-8 with "שלום!" (shalom) in it.</p>
<h2><a class="anchor" id="codecvt_iostreams_integration"></a>
Integration with Boost.Iostreams</h2>
<p>You can use the <code>std::codecvt</code> facet directly, but this is quite tricky and requires accurate buffer and error management.</p>
<p>You can use the <code>boost::iostreams::code_converter</code> class for stream-oriented conversions between the wide-character set and narrow locale character set.</p>
<p>This is a sample program that converts wide to narrow characters for an arbitrary stream:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;boost/iostreams/stream.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/iostreams/categories.hpp&gt;</span> 
<span class="preprocessor">#include &lt;boost/iostreams/code_converter.hpp&gt;</span>

<span class="preprocessor">#include &lt;boost/locale.hpp&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">namespace </span>io = boost::iostreams;

<span class="comment">// Device that consumes the converted text,</span>
<span class="comment">// In our case it just writes to standard output</span>
<span class="keyword">class </span>consumer {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> <span class="keywordtype">char</span> char_type;
    <span class="keyword">typedef</span> io::sink_tag category;
    std::streamsize write(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, std::streamsize n)
    {
        std::cout.write(s,n);
        <span class="keywordflow">return</span> n;
    }
};


<span class="keywordtype">int</span> main()
{ 
    <span class="comment">// the device that converts wide characters</span>
    <span class="comment">// to narrow</span>
    <span class="keyword">typedef</span> io::code_converter&lt;consumer&gt; converter_device;
    <span class="comment">// the stream that uses this device</span>
    <span class="keyword">typedef</span> io::stream&lt;converter_device&gt; converter_stream;


    consumer cons;
    <span class="comment">// setup out converter to work</span>
    <span class="comment">// with he_IL.UTF-8 locale </span>
    converter_device dev;
    <a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
    dev.imbue(gen(<span class="stringliteral">&quot;he_IL.UTF-8&quot;</span>));
    dev.open(cons);
    converter_stream stream;
    stream.open(dev);
    <span class="comment">// Now wide characters that are written</span>
    <span class="comment">// to the stream would be given to</span>
    <span class="comment">// our consumer as narrow characters </span>
    <span class="comment">// in UTF-8 encoding</span>
    stream &lt;&lt; L<span class="stringliteral">&quot;שלום&quot;</span> &lt;&lt; std::flush;
}
</pre></div><h2><a class="anchor" id="codecvt_limitations"></a>
Limitations of std::codecvt</h2>
<p>The Standard does not provide any information about <code>std::mbstate_t</code> that could be used to save intermediate code-page conversion states. It leaves the definition up to the compiler implementation, making it impossible to reimplement <code>std::codecvt&lt;wchar_t,char,mbstate_t&gt;</code> for stateful encodings. Thus, Boost.Locale's <code>codecvt</code> facet implementation may be used with stateless encodings like UTF-8, ISO-8859, and Shift-JIS, but not with stateful encodings like UTF-7 or SCSU.</p>
<p><b>Recommendation:</b> Prefer the Unicode UTF-8 encoding for <code>char</code> based strings and files in your application.</p>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The implementation of codecvt for single byte encodings like ISO-8859-X and for UTF-8 is very efficent and would allow fast conversion of the content, however its performance may be sub-optimal for double-width encodings like Shift-JIS, due to the stateless problem described above. </p>
</div>
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2009-2011 Artyom Beilis,  Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
</small></address>
</body>
</html>
