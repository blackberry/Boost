<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Synchronization</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../thread.html" title="Chapter&#160;28.&#160;Thread 3.1.0">
<link rel="prev" href="thread_management.html" title="Thread Management">
<link rel="next" href="thread_local_storage.html" title="Thread Local Storage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="thread_management.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="thread.synchronization"></a><a class="link" href="synchronization.html" title="Synchronization">Synchronization</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial">Tutorial</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts">Mutex Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks">Lock Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks">Other Lock Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions">Lock functions</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types">Mutex Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref">Condition Variables</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once">One-time Initialization</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers">Barriers</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures">Futures</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.tutorial"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial" title="Tutorial">Tutorial</a>
</h3></div></div></div>
<p>
        <a href="http://home.roadrunner.com/~hinnant/mutexes/locking.html" target="_top">Handling
        mutexes in C++</a> is an excellent tutorial. You need just replace std
        and ting by boost.
      </p>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html" target="_top">Mutex,
        Lock, Condition Variable Rationale</a> adds rationale for the design
        decisions made for mutexes, locks and condition variables.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_concepts"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts" title="Mutex Concepts">Mutex Concepts</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept</a></span></dt>
</dl></div>
<p>
        A mutex object facilitates protection against data races and allows thread-safe
        synchronization of data between threads. A thread obtains ownership of a
        mutex object by calling one of the lock functions and relinquishes ownership
        by calling the corresponding unlock function. Mutexes may be either recursive
        or non-recursive, and may grant simultaneous ownership to one or many threads.
        <span class="bold"><strong>Boost.Thread</strong></span> supplies recursive and non-recursive
        mutexes with exclusive ownership semantics, along with a shared ownership
        (multiple-reader / single-writer) mutex.
      </p>
<p>
        <span class="bold"><strong>Boost.Thread</strong></span> supports four basic concepts
        for lockable objects: <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a>. Each mutex type
        implements one or more of these concepts, as do the various lock types.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept models exclusive
          ownership. A type <code class="computeroutput"><span class="identifier">L</span></code> meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requiremets if the
          following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until ownership can be obtained for the
                  current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd>
<p>
                  <span class="bold"><strong>operation_not_permitted</strong></span>: if the
                  thread does not have the privilege to perform the operation.
                </p>
<p>
                  <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                  if the implementation detects that a deadlock would occur.
                </p>
<p>
                  <span class="bold"><strong>device_or_resource_busy</strong></span>: if the
                  mutex is already locked and blocking is not possible.
                </p>
</dd>
<dt><span class="term">Thread safety:</span></dt>
<dd><p>
                  If an exception is thrown then a lock shall not have been acquired
                  for the current thread.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.unlock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases ownership by the current thread.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a></span></dt></dl></div>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements if it meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span></code></a><span class="special">()</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread without blocking.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns the <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> refines
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to add support
          for timeouts when trying to acquire the lock.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span> </code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements and the
          following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a> must be released
          through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
</dl>
</div>
</div>
<h6>
<a name="thread.synchronization.mutex_concepts.timed_lockable.h0"></a>
          <span><a name="thread.synchronization.mutex_concepts.timed_lockable.deprecated_v3_0_0"></a></span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.deprecated_v3_0_0">Deprecated
          V3.0.0</a>
        </h6>
<p>
          The following expressions were required on version 2, but are now deprecated.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of an unspecified <code class="computeroutput"><span class="identifier">DurationType</span></code>
              arithmetic compatible with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()+</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>shared ownership</em></span> as well as <span class="emphasis"><em>exclusive
          ownership</em></span>. This is the standard multiple-reader / single-write
          model: at most one thread can have exclusive ownership, and if any thread
          does have exclusive ownership, no other threads can have shared or exclusive
          ownership. Alternatively, many threads may have shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span> </code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span> </code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a> must be
          released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until shared ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread without
                  blocking.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified duration
                  is elapsed. If the specified duration is already elapsed, behaves
                  as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<h6>
<a name="thread.synchronization.mutex_concepts.shared_lockable.h0"></a>
          <span><a name="thread.synchronization.mutex_concepts.shared_lockable.deprecated_v3"></a></span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.deprecated_v3">Deprecated
          V3</a>
        </h6>
<p>
          The following expressions were required on version 1, but are now deprecated.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li></ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>upgradable ownership</em></span> as well as <span class="emphasis"><em>shared
          ownership</em></span> and <span class="emphasis"><em>exclusive ownership</em></span>. This
          is an extension to the multiple-reader / single-write model provided by
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>: a single
          thread may have <span class="emphasis"><em>upgradable ownership</em></span> at the same time
          as others have <span class="emphasis"><em>shared ownership</em></span>. The thread with
          <span class="emphasis"><em>upgradable ownership</em></span> may at any time attempt to upgrade
          that ownership to <span class="emphasis"><em>exclusive ownership</em></span>. If no other
          threads have shared ownership, the upgrade is completed immediately, and
          the thread now has <span class="emphasis"><em>exclusive ownership</em></span>, which must
          be relinquished by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>,
          just as if it had been acquired by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>.
        </p>
<p>
          If a thread with <span class="emphasis"><em>upgradable ownership</em></span> tries to upgrade
          whilst other threads have <span class="emphasis"><em>shared ownership</em></span>, the attempt
          will fail and the thread will block until <span class="emphasis"><em>exclusive ownership</em></span>
          can be acquired.
        </p>
<p>
          Ownership can also be <span class="emphasis"><em>downgraded</em></span> as well as <span class="emphasis"><em>upgraded</em></span>:
          exclusive ownership of an implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> can be
          downgraded to upgradable ownership or shared ownership, and upgradable
          ownership can be downgraded to plain shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span> </code></a> requirements
          if it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span> </code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_and_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until" title="m.try_unlock_upgrade_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="m.unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock_shared</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          If `BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION is defined the
          following expressions are also required:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
          If the ownership type is changed through a call to one of the <code class="computeroutput"><span class="identifier">unlock_xxx_and_lock_yyy</span><span class="special">()</span></code>
          functions, ownership must be released through a call to the unlock function
          corresponding to the new level of ownership.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until upgrade ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  Prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership on the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempts to obtain upgrade ownership of the mutex for the calling
                  thread without blocking. If upgrade ownership is not obtained,
                  there is no effect and try_lock_upgrade() immediately returns.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. Attempts
                  to obtain upgrade lock ownership for the calling thread within
                  the relative timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>.
                  If the time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to obtain upgrade ownership of the mutex.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread must hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the shared ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>).
                  The function shall return within the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> only if it has obtained
                  exclusive ownership of the mutex object. For this conversion to
                  be successful, this thread must be the only thread holding any
                  ownership of the lock at the moment of conversion. If the conversion
                  is not successful, the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread within the absolute
                  timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain exclusive ownership
                  without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock at the moment of conversion.
                  If the conversion is not successful, the shared ownership of the
                  mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically converts the ownership from exclusive to shared for
                  the calling thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread without blocking. For
                  this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object. If the conversion is not successful,
                  the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to upgrade
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  upgrade ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of m is
                  retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread within the absolute timeout
                  specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of the mutex
                  is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code> without blocking.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>. If any other threads have
                  shared ownership, blocks until exclusive ownership can be acquired.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  that obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  upgrade to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the upgrade ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from upgrade to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread shall be the
                  only thread holding any ownership of the lock at the moment of
                  conversion. If the conversion is not successful, the upgrade ownership
                  of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until" title="m.try_unlock_upgrade_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  upgrade to exclusive for the calling thread within the absolute
                  timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain exclusive ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread shall be the
                  only thread holding any ownership of the lock at the moment of
                  conversion. If the conversion is not successful, the upgrade ownership
                  of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="m.unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires shared ownership of <code class="computeroutput"><span class="identifier">m</span></code> without blocking.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with prior <code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code> and subsequent lock operations
                  that obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.locks"></a><a class="link" href="synchronization.html#thread.synchronization.locks" title="Lock Types">Lock Types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_tags">Lock option
        tags</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard">Class template
        <code class="computeroutput"><span class="identifier">lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock">Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock">Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_lock">Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock">Class
        template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.scoped_try_lock">Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/locks.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">defer_lock_t</span> <span class="special">{};</span>
  <span class="keyword">struct</span> <span class="identifier">try_to_lock_t</span> <span class="special">{};</span>
  <span class="keyword">struct</span> <span class="identifier">adopt_lock_t</span> <span class="special">{};</span>
  <span class="identifier">constexpr</span> <span class="identifier">defer_lock_t</span> <span class="identifier">defer_lock</span><span class="special">;</span>
  <span class="identifier">constexpr</span> <span class="identifier">try_to_lock_t</span> <span class="identifier">try_to_lock</span><span class="special">;</span>
  <span class="identifier">constexpr</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">adopt_lock</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">lock_guard</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">unique_lock</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">unique_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_lock</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">upgrade_lock</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">upgrade_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">upgrade_to_unique_lock</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.lock_tags"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_tags" title="Lock option tags">Lock option
        tags</a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">defer_lock_t</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">try_to_lock_t</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">adopt_lock_t</span> <span class="special">{};</span>
<span class="keyword">const</span> <span class="identifier">defer_lock_t</span> <span class="identifier">defer_lock</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">try_to_lock_t</span> <span class="identifier">try_to_lock</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">adopt_lock</span><span class="special">;</span>
</pre>
<p>
          These tags are used in scoped locks constructors to specify a specific
          behavior.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">defer_lock_t</span></code>: is used
              to construct the scoped lock without locking it.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">try_to_lock_t</span></code>: is used
              to construct the scoped lock trying to lock it.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">adopt_lock_t</span></code>: is used
              to construct the scoped lock without locking it but adopting ownership.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard">Class template
        <code class="computeroutput"><span class="identifier">lock_guard</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.constructor"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/locks.hpp&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">lock_guard</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">lock_guard</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>
          is very simple: on construction it acquires ownership of the implementation
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> supplied as the
          constructor parameter. On destruction, the ownership is released. This
          provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, to facilitate
          exception-safe locking and unlocking. In addition, the <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code>
          constructor</a> allows the <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a> object to take ownership
          of a lock already held by the current thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor" title="lock_guard(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  equivalent to one obtained by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.destructor" title="~lock_guard()"><code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                  on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed
                  to the constructor.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock">Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_try"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span>
          <span class="identifier">sl</span><span class="special">,</span>
          <span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_until"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_for"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_time_point"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_duration"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.mutex"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.explicit_bool_conversion"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.release"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/locks.hpp&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">)</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
<span class="preprocessor">#endif</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">unique_lock</span><span class="special">();</span>

    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">unique_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">unique_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">absolute_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is more complex than
          <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>:
          not only does it provide for RAII-style locking, it also allows for deferring
          acquiring the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          Specializations of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> model the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span> </code></a> concept if the
          supplied <code class="computeroutput"><span class="identifier">Lockable</span></code> type
          itself models <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span> </code></a> concept (e.g.
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span></code>),
          or the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> concept if the supplied
          <code class="computeroutput"><span class="identifier">Lockable</span></code> type itself models
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> concept (e.g. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>),
          or the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept if the supplied
          <code class="computeroutput"><span class="identifier">Lockable</span></code> type itself models
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is intended to model
          the ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor" title="unique_lock()"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Creates a lock object with no associated mutex.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor" title="unique_lock(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt" title="unique_lock(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer" title="unique_lock(Lockable &amp; m,boost::defer_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try" title="unique_lock(Lockable &amp; m,boost::try_to_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_try" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp; sl, try_to_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span>
          <span class="identifier">sl</span><span class="special">,</span>
          <span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type must implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>. Let <code class="computeroutput"><span class="identifier">pm</span></code> be the pointer to the mutex
                  and <code class="computeroutput"><span class="identifier">owns</span></code> the ownership
                  state. Initializes <code class="computeroutput"><span class="identifier">pm</span></code>
                  with nullptr and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with false. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>, <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_until"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_until" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp;, const chrono::time_point&lt;Clock, Duration&gt;&amp;)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type shall implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a></code>, initializing
                  <code class="computeroutput"><span class="identifier">pm</span></code> with <code class="computeroutput"><span class="identifier">nullptr</span></code> and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with <code class="computeroutput"><span class="keyword">false</span></code>. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span>
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_for"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_for" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp;, const chrono::duration&lt;Rep, Period&gt;&amp;)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type shall implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a></code>, initializing
                  <code class="computeroutput"><span class="identifier">pm</span></code> with <code class="computeroutput"><span class="identifier">nullptr</span></code> and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with <code class="computeroutput"><span class="keyword">false</span></code>. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span>
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  .
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time" title="unique_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_time_point"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_time_point" title="template &lt;class Clock, class Duration&gt; unique_lock(Lockable &amp; m,const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>, and takes ownership of the lock
                  state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a> returned
                  <code class="computeroutput"><span class="keyword">true</span></code>, then <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_duration"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_duration" title="template &lt;class Rep, class Period&gt; unique_lock(Lockable &amp; m,const chrono::duration&lt;Rep, Period&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a> returned
                  <code class="computeroutput"><span class="keyword">true</span></code>, then <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.destructor" title="~unique_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
                  if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                  is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.explicit_bool_conversion"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.explicit_bool_conversion" title="explicit operator bool() const"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.release" title="Lockable* release()"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                  without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                  it is the responsibility of the calling code to ensure that the
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly
                  unlocked.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                  if there is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.shared_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock">Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.mutex"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.explicit_operator_bool"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.release"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/locks.hpp&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

    <span class="comment">// Shared locking</span>
    <span class="identifier">shared_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">shared_lock</span><span class="special">();</span>

    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">shared_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="comment">// Conversion from upgrade locking</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="comment">// Conversion from exclusive locking</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="comment">// Setters</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="comment">// Getters</span>
    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">mutex_type</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> acquires shared ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is intended to model
          the shared ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor" title="shared_lock()"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Creates a lock object with no associated mutex.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor" title="shared_lock(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt" title="shared_lock(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer" title="shared_lock(Lockable &amp; m,boost::defer_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try" title="shared_lock(Lockable &amp; m,boost::try_to_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time" title="shared_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.destructor" title="~shared_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
                  if <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                  is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.explicit_operator_bool"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.explicit_operator_bool" title="explicit operator bool() const"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.release" title="Lockable* release()"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                  without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                  it is the responsibility of the calling code to ensure that the
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly
                  unlocked.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                  if there is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock">Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/locks.hpp&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

    <span class="comment">// Upgrade locking</span>

    <span class="identifier">upgrade_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">defer_lock_t</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
                 <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
                 <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">upgrade_lock</span><span class="special">();</span>

    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span>
   <span class="comment">// Conversion from shared locking</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                   <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                   <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

    <span class="comment">// Conversion from exclusive locking</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="comment">// Setters</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>

    <span class="comment">// Getters</span>
    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">mutex_type</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> acquires upgrade
          ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is intended to model
          the upgrade ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_to_unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock">Class
        template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_to_unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">();</span>

    <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> allows
          for a temporary upgrade of an <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> to exclusive ownership.
          When constructed with a reference to an instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a>, if that instance
          has upgrade ownership on some <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, that ownership
          is upgraded to exclusive ownership. When the <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> instance
          is destroyed, the ownership of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is downgraded back to
          <span class="emphasis"><em>upgrade ownership</em></span>.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.scoped_try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.scoped_try_lock" title="Mutex-specific class scoped_try_lock">Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>

    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          The member typedef <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code>
          is provided for each distinct <code class="computeroutput"><span class="identifier">MutexType</span></code>
          as a typedef to a class with the preceding definition. The semantics of
          each constructor and member function are identical to those of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;</span></code></a>
          for the same <code class="computeroutput"><span class="identifier">MutexType</span></code>,
          except that the constructor that takes a single reference to a mutex will
          call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a> rather than <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.other_locks"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks" title="Other Lock Types">Other Lock Types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard">Class
        template <code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock">Class
        template <code class="computeroutput"><span class="identifier">reverse_lock</span></code></a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard">Class
        template <code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor_adopt"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/shared_lock_guard.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">SharedLockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_lock_guard</span>
  <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
      <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">shared_lock_guard</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
      <span class="identifier">shared_lock_guard</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock_guard</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

      <span class="keyword">explicit</span> <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
      <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>

      <span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">();</span>
  <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a> is very simple:
          on construction it acquires shared ownership of the implementation of the
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> supplied
          as the constructor parameter. On destruction, the ownership is released.
          This provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> object, to facilitate
          exception-safe shared locking and unlocking. In addition, the <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code> constructor allows the <a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a> object to take
          shared ownership of a lock already held by the current thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor" title="shared_lock_guard(SharedLockable &amp; m)"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor_adopt" title="shared_lock_guard(SharedLockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  equivalent to one obtained by a call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.destructor" title="~shared_lock_guard()"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code> on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> object
                  passed to the constructor.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.reverse_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock">Class
        template <code class="computeroutput"><span class="identifier">reverse_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock.constructor"><code class="computeroutput"><span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/reverse_lock.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">reverse_lock</span>
  <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
      <span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">reverse_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
      <span class="identifier">reverse_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">reverse_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

      <span class="keyword">explicit</span> <span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
      <span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">();</span>
  <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock"><code class="computeroutput"><span class="identifier">reverse_lock</span></code></a> reverse the operations
          of a lock: it provide for RAII-style, that unlocks the lock at construction
          time and lock it at destruction time. In addition, it transfer ownership
          temporarily, so that the mutex can not be locked using the Lock.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock"><code class="computeroutput"><span class="identifier">reverse_lock</span></code></a> doesn't <span class="emphasis"><em>own</em></span>
          the lock never.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.reverse_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock.constructor" title="reverse_lock(Lock &amp; m)"><code class="computeroutput"><span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  if <code class="computeroutput"><span class="identifier">m</span></code> owns his lock
                  and then stores the mutex by calling <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">!</span><span class="identifier">m</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span> <span class="special">&amp;&amp;</span>
                  <span class="identifier">m</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.reverse_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock.destructor" title="~reverse_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Let be mtx the stored mutex*. If not 0 Invokes <code class="computeroutput"><span class="identifier">mtx</span><span class="special">-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">()</span></code>
                  and gives again the <code class="computeroutput"><span class="identifier">mtx</span></code>
                  to the <code class="computeroutput"><span class="identifier">Lock</span></code> using
                  the <code class="computeroutput"><span class="identifier">adopt_lock_t</span></code>
                  overload.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_functions"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions" title="Lock functions">Lock functions</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_multiple">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_range">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_range">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_multiple" title="Non-member function lock(Lockable1,Lockable2,...)">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>

<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Locks the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
                as arguments in an unspecified and indeterminate order in a way that
                avoids deadlock. It is safe to call this function concurrently from
                multiple threads with the same mutexes (or other lockable objects)
                in different orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                All the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
                by the calling thread.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_range" title="Non-member function lock(begin,end)">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                The <code class="computeroutput"><span class="identifier">value_type</span></code> of
                <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
                implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Locks all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range in an unspecified and indeterminate order in a way
                that avoids deadlock. It is safe to call this function concurrently
                from multiple threads with the same mutexes (or other lockable objects)
                in different orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range throws an exception any locks acquired by the function
                will be released before the function exits.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                All the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range are locked by the calling thread.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple" title="Non-member function try_lock(Lockable1,Lockable2,...)">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
                as arguments. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code> then all
                locks acquired are released and the zero-based index of the failed
                lock is returned.
              </p>
<p>
                If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
                if all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now
                locked by the calling thread, the zero-based index of the object
                which could not be locked otherwise.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the function returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>, all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
                by the calling thread. Otherwise any locks acquired by this function
                will have been released.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_range" title="Non-member function try_lock(begin,end)">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="identifier">ForwardIterator</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                The <code class="computeroutput"><span class="identifier">value_type</span></code> of
                <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
                implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code> then all
                locks acquired are released and an iterator referencing the failed
                lock is returned.
              </p>
<p>
                If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">end</span></code> if all the supplied
                <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now
                locked by the calling thread, an iterator referencing the object
                which could not be locked otherwise.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the function returns <code class="computeroutput"><span class="identifier">end</span></code>
                then all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range are locked by the calling thread, otherwise all locks
                acquired by the function have been released.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_types"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types" title="Mutex Types">Mutex Types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex">Class <code class="computeroutput"><span class="identifier">mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex">Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.shared_mutex">Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.upgrade_mutex">Class
        <code class="computeroutput"><span class="identifier">upgrade_mutex</span></code></a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex">Class <code class="computeroutput"><span class="identifier">mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership mutex. At most one thread can own the lock on a given
          instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> at any time. Multiple concurrent
          calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">mutex</span> <span class="identifier">try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code>
          to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a>, provided for backwards
          compatibility with previous releases of boost.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex">Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">timed_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_timed_lock</span> <span class="identifier">scoped_lock</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership mutex. At most one thread can own the lock on a
          given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> implements the
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership recursive mutex. At most one thread can own the lock
          on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> instance can call
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">recursive_mutex</span> <span class="identifier">recursive_try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code> to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a>, provided for
          backwards compatibility with previous releases of boost.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_timed_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>


    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_lock</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> implements
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership recursive mutex. At most one thread can own the
          lock on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> at any time.
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> instance
          can call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.shared_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.shared_mutex" title="Class shared_mutex">Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">shared_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">shared_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">shared_mutex</span><span class="special">(</span><span class="identifier">shared_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">shared_mutex</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">shared_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">shared_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
    <span class="comment">// use upgrade_mutex instead.</span>
    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span>
<span class="preprocessor">#endif</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_mutex</span></code> provides an implementation
          of a multiple-reader / single-writer mutex. It implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>.
        </p>
<p>
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          are permitted.
        </p>
<p>
          Note the the lack of reader-writer priority policies in shared_mutex. This
          is due to an algorithm credited to Alexander Terekhov which lets the OS
          decide which thread is the next to get the lock without caring whether
          a unique lock or shared lock is being sought. This results in a complete
          lack of reader or writer starvation. It is simply fair.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.upgrade_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.upgrade_mutex" title="Class upgrade_mutex">Class
        <code class="computeroutput"><span class="identifier">upgrade_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">shared_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">upgrade_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">upgrade_mutex</span><span class="special">(</span><span class="identifier">upgrade_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_mutex</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">upgrade_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Exclusive</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Upgrade</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Upgrade &lt;-&gt; Exclusive</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span>
<span class="preprocessor">#if</span>    <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_THREAD_PLATFORM_PTHREAD</span><span class="special">)</span>
    <span class="special">||</span> <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span><span class="special">)</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_mutex</span></code> provides an implementation
          of a multiple-reader / single-writer mutex. It implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a>.
        </p>
<p>
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          are permitted.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.condvar_ref"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref" title="Condition Variables">Condition Variables</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a></span></dt>
</dl></div>
<h5>
<a name="thread.synchronization.condvar_ref.h0"></a>
        <span><a name="thread.synchronization.condvar_ref.synopsis"></a></span><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span>
  <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
  <span class="special">};</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        The classes <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        and <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        provide a mechanism for one thread to wait for notification from another
        thread that a particular condition has become true. The general usage pattern
        is that one thread locks a mutex and then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        on an instance of <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        or <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
        When the thread is woken from the wait, then it checks to see if the appropriate
        condition is now true, and continues if so. If the condition is not true,
        then the thread then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        again to resume waiting. In the simplest case, this condition is just a boolean
        variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mut</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
    <span class="keyword">while</span><span class="special">(!</span><span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lock</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the thread to the set of threads waiting on the condition
        variable, and unlock the mutex. When the thread is woken, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other threads to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        In the mean time, another thread sets the condition to <code class="computeroutput"><span class="keyword">true</span></code>,
        and then calls either <code class="computeroutput"><span class="identifier">notify_one</span></code>
        or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition
        variable to wake one waiting thread or all the waiting threads respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
        <span class="identifier">data_ready</span><span class="special">=</span><span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<p>
        This example uses an object of type <code class="computeroutput"><span class="identifier">condition_variable</span></code>,
        but would work just as well with an object of type <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>:
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code> is
        more general, and will work with any kind of lock or mutex, whereas <code class="computeroutput"><span class="identifier">condition_variable</span></code> requires that the lock
        passed to <code class="computeroutput"><span class="identifier">wait</span></code> is an instance
        of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>.
        This enables <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        to make optimizations in some cases, based on the knowledge of the mutex
        type; <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        typically has a more complex implementation than <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable" title="Class condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>

        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>

    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor" title="condition_variable()"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor" title="~condition_variable()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait" title="void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate" title="template&lt;typename predicate_type&gt; void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait" title="bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel" title="template&lt;typename duration_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate" title="template&lt;typename predicate_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until" title="template &lt;class Clock, class Duration&gt; cv_status wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code> in all the threads
                  currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for" title="template &lt;class Rep, class Period&gt; cv_status wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_until</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span> </code> if the call is returning
                  because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  has elapsed, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span>
                  </code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate" title="template &lt;class Clock, class Duration, class Predicate&gt; bool wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate" title="template &lt;class Rep, class Period, class Predicate&gt; bool wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">rel_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any" title="Class condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable_any</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable_any</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>


        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor" title="condition_variable_any()"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor" title="~condition_variable_any()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait" title="template&lt;typename lock_type&gt; void wait(lock_type&amp; lock)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; void wait(lock_type&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait" title="template&lt;typename lock_type&gt; bool timed_wait(lock_type&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel" title="template&lt;typename lock_type,typename duration_type&gt; bool timed_wait(lock_type&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; bool timed_wait(lock_type&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for" title="template &lt;class lock_type, class Rep, class Period&gt; cv_status wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate" title="template &lt;class lock_type, class Clock, class Duration, class Predicate&gt; bool wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="identifier">wait_until</span></code></a><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate" title="template &lt;class lock_type, class Rep, class Period, class Predicate&gt; bool wait_until(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for" title="template &lt;class lock_type, class Rep, class Period&gt; cv_status wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="identifier">wait_for</span></code></a><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">rel_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition" title="Typedef condition DEPRECATED V3">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">typedef</span> <span class="identifier">condition_variable_any</span> <span class="identifier">condition</span><span class="special">;</span>

<span class="special">}</span>
</pre>
<p>
          The typedef <code class="computeroutput"><span class="identifier">condition</span></code> is
          provided for backwards compatibility with previous boost releases.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.notify_all_at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit" title="Non-member Function notify_all_at_thread_exit()">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
                calling thread and either no other thread is waiting on <code class="computeroutput"><span class="identifier">cond</span></code>, or <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code> returns the same value for each
                of the lock arguments supplied by all concurrently waiting (via
                <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code>, or <code class="computeroutput"><span class="identifier">wait_until</span></code>)
                threads.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                transfers ownership of the lock associated with <code class="computeroutput"><span class="identifier">lk</span></code>
                into internal storage and schedules <code class="computeroutput"><span class="identifier">cond</span></code>
                to be notified when the current thread exits, after all objects of
                thread storage duration associated with the current thread have been
                destroyed. This notification shall be as if
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_all</span><span class="special">();</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.once"></a><a class="link" href="synchronization.html#thread.synchronization.once" title="One-time Initialization">One-time Initialization</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.once_flag">Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.call_once">Non-member function
        <code class="computeroutput"><span class="identifier">call_once</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">once</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">once_flag</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Callable</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">,</span><span class="identifier">Callable</span> <span class="identifier">func</span><span class="special">);</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
  <span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="keyword">void</span> <span class="special">(*</span><span class="identifier">func</span><span class="special">)(),</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">}</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">call_once</span></code> provides a mechanism for ensuring
        that an initialization routine is run exactly once without data races or
        deadlocks.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.once_flag"></a><a class="link" href="synchronization.html#thread.synchronization.once.once_flag" title="Typedef once_flag">Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_ONCE_CXX11</span>
<span class="keyword">struct</span> <span class="identifier">once_flag</span>
<span class="special">{</span>
  <span class="identifier">constexprr</span> <span class="identifier">once_flag</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">once_flag</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">once_flag</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">once_flag</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
<span class="special">};</span>
<span class="preprocessor">#else</span>
<span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">once_flag</span><span class="special">;</span>
<span class="preprocessor">#define</span> <span class="identifier">BOOST_ONCE_INIT</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">initializer</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
          Objects of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span></code> shall be initialized with
          <code class="computeroutput"><span class="identifier">BOOST_ONCE_INIT</span></code> if BOOST_THREAD_PROVIDES_ONCE_CXX11
          is not defined
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span> <span class="identifier">f</span><span class="special">=</span><span class="identifier">BOOST_ONCE_INIT</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.call_once"></a><a class="link" href="synchronization.html#thread.synchronization.once.call_once" title="Non-member function call_once">Non-member function
        <code class="computeroutput"><span class="identifier">call_once</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Callable</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">,</span><span class="identifier">Callable</span> <span class="identifier">func</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">Callable</span></code> is <code class="computeroutput"><span class="identifier">CopyConstructible</span></code>. Copying <code class="computeroutput"><span class="identifier">func</span></code> shall have no side effects,
                and the effect of calling the copy shall be equivalent to calling
                the original.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Calls to <code class="computeroutput"><span class="identifier">call_once</span></code>
                on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object are serialized. If there has been no prior effective <code class="computeroutput"><span class="identifier">call_once</span></code> on the same <code class="computeroutput"><span class="identifier">once_flag</span></code> object, the argument
                <code class="computeroutput"><span class="identifier">func</span></code> (or a copy thereof)
                is called as-if by invoking <code class="computeroutput"><span class="identifier">func</span><span class="special">()</span></code>, and the invocation of <code class="computeroutput"><span class="identifier">call_once</span></code> is effective if and only
                if <code class="computeroutput"><span class="identifier">func</span><span class="special">()</span></code>
                returns without exception. If an exception is thrown, the exception
                is propagated to the caller. If there has been a prior effective
                <code class="computeroutput"><span class="identifier">call_once</span></code> on the
                same <code class="computeroutput"><span class="identifier">once_flag</span></code> object,
                the <code class="computeroutput"><span class="identifier">call_once</span></code> returns
                without invoking <code class="computeroutput"><span class="identifier">func</span></code>.
              </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                The completion of an effective <code class="computeroutput"><span class="identifier">call_once</span></code>
                invocation on a <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object, synchronizes with all subsequent <code class="computeroutput"><span class="identifier">call_once</span></code>
                invocations on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">thread_resource_error</span></code>
                when the effects cannot be achieved. or any exception propagated
                from <code class="computeroutput"><span class="identifier">func</span></code>.
              </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                The function passed to <code class="computeroutput"><span class="identifier">call_once</span></code>
                must not also call <code class="computeroutput"><span class="identifier">call_once</span></code>
                passing the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object. This may cause deadlock, or invoking the passed function
                a second time. The alternative is to allow the second call to return
                immediately, but that assumes the code knows it has been called recursively,
                and can proceed even though the call to <code class="computeroutput"><span class="identifier">call_once</span></code>
                didn't actually call the function, in which case it could also avoid
                calling <code class="computeroutput"><span class="identifier">call_once</span></code>
                recursively.
              </p></dd>
</dl>
</div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="keyword">void</span> <span class="special">(*</span><span class="identifier">func</span><span class="special">)(),</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">);</span>
</pre>
<p>
          This second overload is provided for backwards compatibility. The effects
          of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">func</span><span class="special">,</span><span class="identifier">flag</span><span class="special">)</span></code>
          shall be the same as those of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">flag</span><span class="special">,</span><span class="identifier">func</span><span class="special">)</span></code>.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.barriers"></a><a class="link" href="synchronization.html#thread.synchronization.barriers" title="Barriers">Barriers</a>
</h3></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier">Class <code class="computeroutput"><span class="identifier">barrier</span></code></a></span></dt></dl></div>
<p>
        A barrier is a simple concept. Also known as a <span class="emphasis"><em>rendezvous</em></span>,
        it is a synchronization point between multiple threads. The barrier is configured
        for a particular number of threads (<code class="computeroutput"><span class="identifier">n</span></code>),
        and as threads reach the barrier they must wait until all <code class="computeroutput"><span class="identifier">n</span></code>
        threads have arrived. Once the <code class="computeroutput"><span class="identifier">n</span></code>-th
        thread has reached the barrier, all the waiting threads can proceed, and
        the barrier is reset.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.barriers.barrier"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier">Class <code class="computeroutput"><span class="identifier">barrier</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">barrier</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">barrier</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          Instances of <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">barrier</span></code></a> are not copyable or movable.
        </p>
<h6>
<a name="thread.synchronization.barriers.barrier.h0"></a>
          <span><a name="thread.synchronization.barriers.barrier.constructor"></a></span><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.constructor">Constructor</a>
        </h6>
<pre class="programlisting"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Construct a barrier for <code class="computeroutput"><span class="identifier">count</span></code>
                threads.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
<h6>
<a name="thread.synchronization.barriers.barrier.h1"></a>
          <span><a name="thread.synchronization.barriers.barrier.destructor"></a></span><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.destructor">Destructor</a>
        </h6>
<pre class="programlisting"><span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                No threads are waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
<h6>
<a name="thread.synchronization.barriers.barrier.h2"></a>
          <span><a name="thread.synchronization.barriers.barrier.member_function__code__phrase_role__identifier__wait__phrase___code_"></a></span><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.member_function__code__phrase_role__identifier__wait__phrase___code_">Member
          function <code class="computeroutput"><span class="identifier">wait</span></code></a>
        </h6>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Block until <code class="computeroutput"><span class="identifier">count</span></code>
                threads have called <code class="computeroutput"><span class="identifier">wait</span></code>
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                When the <code class="computeroutput"><span class="identifier">count</span></code>-th
                thread calls <code class="computeroutput"><span class="identifier">wait</span></code>,
                all waiting threads are unblocked, and the barrier is reset.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> for exactly one
                thread from each batch of waiting threads, <code class="computeroutput"><span class="keyword">false</span></code>
                otherwise.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.futures"></a><a class="link" href="synchronization.html#thread.synchronization.futures" title="Futures">Futures</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.overview">Overview</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.creating">Creating asynchronous
        values</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.lazy_futures">Wait Callbacks
        and Lazy Futures</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference">Futures Reference</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.overview"></a><a class="link" href="synchronization.html#thread.synchronization.futures.overview" title="Overview">Overview</a>
</h4></div></div></div>
<p>
          The futures library provides a means of handling synchronous future values,
          whether those values are generated by another thread, or on a single thread
          in response to external stimuli, or on-demand.
        </p>
<p>
          This is done through the provision of four class templates: <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> which are used to
          retrieve the asynchronous results, and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> which are used to
          generate the asynchronous results.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> holds the one and only
          reference to a result. Ownership can be transferred between instances using
          the move constructor or move-assignment operator, but at most one instance
          holds a reference to a given asynchronous result. When the result is ready,
          it is returned from <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          by rvalue-reference to allow the result to be moved or copied as appropriate
          for the type.
        </p>
<p>
          On the other hand, many instances of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> may reference the
          same result. Instances can be freely copied and assigned, and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          returns a <code class="computeroutput"><span class="keyword">const</span></code> reference
          so that multiple calls to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          are safe. You can move an instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> into an instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, thus transferring
          ownership of the associated asynchronous result, but not vice-versa.
        </p>
<p>
          You can wait for futures either individually or with one of the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_any" title="Non-member function wait_for_any()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">wait_for_any</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_all" title="Non-member function wait_for_all()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">wait_for_all</span><span class="special">()</span></code></a>
          functions.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.creating"></a><a class="link" href="synchronization.html#thread.synchronization.futures.creating" title="Creating asynchronous values">Creating asynchronous
        values</a>
</h4></div></div></div>
<p>
          You can set the value in a future with either a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>. A <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> is a callable object
          that wraps a function or callable object. When the packaged task is invoked,
          it invokes the contained function in turn, and populates a future with
          the return value. This is an answer to the perennial question: "how
          do I return a value from a thread?": package the function you wish
          to run as a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> and pass the packaged
          task to the thread constructor. The future retrieved from the packaged
          task can then be used to obtain the return value. If the function throws
          an exception, that is stored in the future in place of the return value.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pt</span><span class="special">(</span><span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">=</span><span class="identifier">pt</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">task</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pt</span><span class="special">));</span> <span class="comment">// launch task on a thread</span>

<span class="identifier">fi</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span> <span class="comment">// wait for it to finish</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get_state</span><span class="special">()==</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
<p>
          A <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> is a bit more low level:
          it just provides explicit functions to store a value or an exception in
          the associated future. A promise can therefore be used where the value
          may come from more than one possible source, or where a single operation
          may produce multiple values.
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">;</span>
<span class="identifier">fi</span><span class="special">=</span><span class="identifier">pi</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>

<span class="identifier">pi</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="number">42</span><span class="special">);</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get_state</span><span class="special">()==</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.lazy_futures"></a><a class="link" href="synchronization.html#thread.synchronization.futures.lazy_futures" title="Wait Callbacks and Lazy Futures">Wait Callbacks
        and Lazy Futures</a>
</h4></div></div></div>
<p>
          Both <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> support <span class="emphasis"><em>wait
          callbacks</em></span> that are invoked when a thread blocks in a call to
          <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
          or <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
          on a future that is waiting for the result from the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>, in the thread that
          is doing the waiting. These can be set using the <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code> member function on the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> in question.
        </p>
<p>
          This allows <span class="emphasis"><em>lazy futures</em></span> where the result is not actually
          computed until it is needed by some thread. In the example below, the call
          to <code class="computeroutput"><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span></code>
          invokes the callback <code class="computeroutput"><span class="identifier">invoke_lazy_task</span></code>,
          which runs the task to set the value. If you remove the call to <code class="computeroutput"><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span></code>, the task is not ever run.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">invoke_lazy_task</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;</span> <span class="identifier">task</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">try</span>
    <span class="special">{</span>
        <span class="identifier">task</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">catch</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_started</span><span class="special">&amp;)</span>
    <span class="special">{}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">task</span><span class="special">(</span><span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">);</span>
    <span class="identifier">task</span><span class="special">.</span><span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">invoke_lazy_task</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">task</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">());</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.reference"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference" title="Futures Reference">Futures Reference</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_state">Enumeration
          <code class="computeroutput"><span class="identifier">state</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_errc">Enumeration
          <code class="computeroutput"><span class="identifier">future_errc</span> </code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.launch">Enumeration
          <code class="computeroutput"><span class="identifier">launch</span> </code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.is_error_code_enum">Specialization
          <code class="computeroutput"><span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_error_code">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_code</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_error_condition">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_condition</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_category">Non-member
          function <code class="computeroutput"><span class="identifier">future_category</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_error">Class
          <code class="computeroutput"><span class="identifier">future_error</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_status">Enumeration
          <code class="computeroutput"><span class="identifier">future_status</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.unique_future"><code class="computeroutput"><span class="identifier">future</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.shared_future"><code class="computeroutput"><span class="identifier">shared_future</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.promise"><code class="computeroutput"><span class="identifier">promise</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.packaged_task"><code class="computeroutput"><span class="identifier">packaged_task</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.decay_copy">Non-member
          function <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.async">Non-member
          function <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.wait_for_any">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.wait_for_all">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/futures.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
  <span class="keyword">namespace</span> <span class="identifier">future_state</span>
  <span class="special">{</span>
    <span class="keyword">enum</span> <span class="identifier">state</span> <span class="special">{</span><span class="identifier">uninitialized</span><span class="special">,</span> <span class="identifier">waiting</span><span class="special">,</span> <span class="identifier">ready</span><span class="special">,</span> <span class="identifier">moved</span><span class="special">};</span>
  <span class="special">}</span>
<span class="preprocessor">#endif</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_errc</span>
  <span class="special">{</span>
    <span class="identifier">broken_promise</span><span class="special">,</span>
    <span class="identifier">future_already_retrieved</span><span class="special">,</span>
    <span class="identifier">promise_already_satisfied</span><span class="special">,</span>
    <span class="identifier">no_state</span>
  <span class="special">};</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">launch</span>
  <span class="special">{</span>
    <span class="identifier">async</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
    <span class="identifier">deferred</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
    <span class="identifier">any</span> <span class="special">=</span> <span class="identifier">async</span> <span class="special">|</span> <span class="identifier">deferred</span>
  <span class="special">};</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_status</span> <span class="special">{</span>
    <span class="identifier">ready</span><span class="special">,</span>  <span class="identifier">timeout</span><span class="special">,</span> <span class="identifier">deferred</span>
  <span class="special">};</span>

  <span class="keyword">namespace</span> <span class="identifier">system</span>
  <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">true_type</span> <span class="special">{};</span>

    <span class="identifier">error_code</span> <span class="identifier">make_error_code</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>

    <span class="identifier">error_condition</span> <span class="identifier">make_error_condition</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
  <span class="special">}</span>

  <span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span><span class="special">&amp;</span> <span class="identifier">future_category</span><span class="special">();</span>

  <span class="keyword">class</span> <span class="identifier">future_error</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">promise</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">namespace</span> <span class="identifier">container</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">uses_allocator</span><span class="special">&lt;</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;,</span> <span class="identifier">Alloc</span><span class="special">&gt;::</span> <span class="identifier">true_type</span><span class="special">;</span>
  <span class="special">}</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">future</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_future</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">packaged_task</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">R</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;,</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;)</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span><span class="special">&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">uses_allocator</span><span class="special">&lt;</span><span class="identifier">packaged_task</span> <span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;,</span> <span class="identifier">Alloc</span><span class="special">&gt;;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="comment">// template &lt;class F, class... Args&gt;</span>
  <span class="comment">// future&lt;typename result_of&lt;typename decay&lt;F&gt;::type(typename decay&lt;Args&gt;::type...)&gt;::type&gt;</span>
  <span class="comment">// async(F&amp;&amp; f, Args&amp;&amp;... args); // NOT YET IMPLEMENTED</span>
  <span class="comment">// template &lt;class F, class... Args&gt;</span>
  <span class="comment">// future&lt;typename result_of&lt;typename decay&lt;F&gt;::type(typename decay&lt;Args&gt;::type...)&gt;::type&gt;</span>
  <span class="comment">// async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args); // NOT YET IMPLEMENTED</span>


  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span><span class="special">...</span> <span class="identifier">FS</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">Fs</span><span class="special">&amp;...</span> <span class="identifier">fs</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
  <span class="identifier">Iterator</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Fs</span><span class="special">&gt;</span>
  <span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">Fs</span><span class="special">&amp;...</span> <span class="identifier">fs</span><span class="special">);</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state">Enumeration
          <code class="computeroutput"><span class="identifier">state</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">future_state</span>
<span class="special">{</span>
  <span class="keyword">enum</span> <span class="identifier">state</span> <span class="special">{</span><span class="identifier">uninitialized</span><span class="special">,</span> <span class="identifier">waiting</span><span class="special">,</span> <span class="identifier">ready</span><span class="special">,</span> <span class="identifier">moved</span><span class="special">};</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_errc"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_errc" title="Enumeration future_errc">Enumeration
          <code class="computeroutput"><span class="identifier">future_errc</span> </code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_errc</span>
<span class="special">{</span>
  <span class="identifier">broken_promise</span><span class="special">,</span>
  <span class="identifier">future_already_retrieved</span><span class="special">,</span>
  <span class="identifier">promise_already_satisfied</span><span class="special">,</span>
  <span class="identifier">no_state</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.launch"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.launch" title="Enumeration launch">Enumeration
          <code class="computeroutput"><span class="identifier">launch</span> </code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">launch</span>
<span class="special">{</span>
  <span class="identifier">async</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
  <span class="identifier">deferred</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
  <span class="identifier">any</span> <span class="special">=</span> <span class="identifier">async</span> <span class="special">|</span> <span class="identifier">deferred</span>
<span class="special">};</span>
</pre>
<p>
            The enum type launch is a bitmask type with launch::async and launch::deferred
            denoting individual bits.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.is_error_code_enum"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.is_error_code_enum" title="Specialization is_error_code_enum&lt;future_errc&gt;">Specialization
          <code class="computeroutput"><span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">true_type</span> <span class="special">{};</span>

<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_error_code"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_error_code" title="Non-member function make_error_code()">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_code</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="identifier">error_code</span> <span class="identifier">make_error_code</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">error_code</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">e</span><span class="special">),</span>
                  <span class="identifier">future_category</span><span class="special">())</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_error_condition"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_error_condition" title="Non-member function make_error_condition()">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_condition</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="identifier">error_condition</span> <span class="identifier">make_error_condition</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">error_condition</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">e</span><span class="special">),</span> <span class="identifier">future_category</span><span class="special">())</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_category"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_category" title="Non-member function future_category()">Non-member
          function <code class="computeroutput"><span class="identifier">future_category</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span><span class="special">&amp;</span> <span class="identifier">future_category</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A reference to an object of a type derived from class error_category.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  The object's <code class="computeroutput"><span class="identifier">default_error_condition</span></code>
                  and equivalent virtual functions behave as specified for the class
                  <code class="computeroutput"><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span></code>. The object's
                  <code class="computeroutput"><span class="identifier">name</span></code> virtual function
                  returns a pointer to the string "future".
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_error"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error" title="Class future_error">Class
          <code class="computeroutput"><span class="identifier">future_error</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">future_error</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">future_error</span><span class="special">(</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">);</span>

    <span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">code</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">no_except</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.future_error.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error.constructor" title="Constructor">Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_error</span><span class="special">(</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a future_error.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">code</span><span class="special">()==</span><span class="identifier">ec</span></code>
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.future_error.code"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error.code" title="Member function code()">Member
            function <code class="computeroutput"><span class="identifier">code</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">code</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">no_except</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The value of <code class="computeroutput"><span class="identifier">ec</span></code>
                    that was passed to the object's constructor.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_status"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_status" title="Enumeration future_status">Enumeration
          <code class="computeroutput"><span class="identifier">future_status</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_status</span> <span class="special">{</span>
  <span class="identifier">ready</span><span class="special">,</span>  <span class="identifier">timeout</span><span class="special">,</span> <span class="identifier">deferred</span>
<span class="special">};</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.unique_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>
<span class="special">{</span>

<span class="keyword">public</span><span class="special">:</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="special">~</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>

  <span class="comment">// move support</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">share</span><span class="special">();</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// retrieving the value</span>
  <span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">get</span><span class="special">();</span>

  <span class="comment">// functions to check state</span>
  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// waiting for the result to be ready</span>
  <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
  <span class="keyword">typedef</span> <span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">state</span><span class="special">;</span>
  <span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an uninitialized <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span></code></a> returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>, and transfers
                    ownership of the asynchronous result associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with an
                    asynchronous result, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    <code class="computeroutput"><span class="identifier">other</span></code> is not
                    associated with any asynchronous result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the asynchronous result associated with
                    <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with an
                    asynchronous result, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    <code class="computeroutput"><span class="identifier">other</span></code> is not
                    associated with any asynchronous result. If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was associated with an asynchronous
                    result prior to the call, that result no longer has an associated
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> instance.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.swap"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.swap" title="Member function swap()">Member
            function <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">no_except</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Swaps ownership of the asynchronous results associated with
                    <code class="computeroutput"><span class="identifier">other</span></code> and <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns the value of <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with an
                    asynchronous result, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    otherwise <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no associated result. If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was associated with an asynchronous
                    result, that result is now associated with <code class="computeroutput"><span class="identifier">other</span></code>,
                    otherwise <code class="computeroutput"><span class="identifier">other</span></code>
                    has no associated result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get" title="Member function get()">Member
            function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">get</span><span class="special">();</span>
<span class="identifier">R</span><span class="special">&amp;</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get</span><span class="special">();</span>
<span class="keyword">void</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready as-if by a call to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait" title="Member function wait()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">wait</span><span class="special">()</span></code></a>,
                    and retrieves the result (whether that is a value or an exception).
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    If the result type <code class="computeroutput"><span class="identifier">R</span></code>
                    is a reference, returns the stored reference. If <code class="computeroutput"><span class="identifier">R</span></code> is <code class="computeroutput"><span class="keyword">void</span></code>,
                    there is no return value. Otherwise, returns an rvalue-reference
                    to the value stored in the asynchronous result.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    stored in the asynchronous result in place of a value.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait" title="Member function wait()">Member
            function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.timed_wait_duration"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.timed_wait_duration" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, and that result is
                    ready before the specified time has elapsed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.timed_wait_absolute"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.timed_wait_absolute" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_timeout</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, and that result is
                    ready before the specified time has passed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait_for" title="Member function wait_for()">Member
            function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the relative timeout specified
                    by <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    expired.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait_until" title="Member function wait_until()">Member
            function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the absolute timeout specified
                    by <code class="computeroutput"><span class="identifier">absl_time</span></code>
                    has reached.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.valid"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.valid" title="Member function valid()">Member
            function <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.is_ready"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result and that result is
                    ready for retrieval, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.has_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_value" title="Member function has_value() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, that result is ready
                    for retrieval, and the result is a stored value, <code class="computeroutput"><span class="keyword">false</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.has_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_exception" title="Member function has_exception() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, that result is ready
                    for retrieval, and the result is a stored exception, <code class="computeroutput"><span class="keyword">false</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state()">Member
            function <code class="computeroutput"><span class="identifier">get_state</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Determine the state of the asynchronous result associated with
                    <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    if any.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a> if the asynchronous
                    result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is ready for retrieval,
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">waiting</span></code></a> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.shared_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">shared_future</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_future</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">state</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="identifier">shared_future</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="special">~</span><span class="identifier">shared_future</span><span class="special">();</span>

  <span class="comment">// copy support</span>
  <span class="identifier">shared_future</span><span class="special">(</span><span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

  <span class="comment">// move support</span>
  <span class="identifier">shared_future</span><span class="special">(</span><span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

  <span class="comment">// retrieving the value</span>
  <span class="identifier">R</span> <span class="identifier">get</span><span class="special">();</span>

  <span class="comment">// functions to check state, and wait for ready</span>
  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// waiting for the result to be ready</span>
  <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
  <span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>
<span class="preprocessor">#endif</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an uninitialized shared_future.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span></code></a> returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.get"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()">Member
            function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready as-if by a call to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait" title="Member function wait()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">wait</span><span class="special">()</span></code></a>,
                    and returns a <code class="computeroutput"><span class="keyword">const</span></code>
                    reference to the result.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    If the result type <code class="computeroutput"><span class="identifier">R</span></code>
                    is a reference, returns the stored reference. If <code class="computeroutput"><span class="identifier">R</span></code> is <code class="computeroutput"><span class="keyword">void</span></code>,
                    there is no return value. Otherwise, returns a <code class="computeroutput"><span class="keyword">const</span></code> reference to the value stored
                    in the asynchronous result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait" title="Member function wait()">Member
            function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.timed_wait_duration"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.timed_wait_duration" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, and that result is
                    ready before the specified time has elapsed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.timed_wait_absolute"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.timed_wait_absolute" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_timeout</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, and that result is
                    ready before the specified time has passed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait_for" title="Member function wait_for()">Member
            function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the relative timeout specified
                    by <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    expired.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait_until" title="Member function wait_until()">Member
            function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, waits until the result
                    is ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the absolute timeout specified
                    by <code class="computeroutput"><span class="identifier">absl_time</span></code>
                    has reached.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted. Any exception
                    thrown by the <span class="emphasis"><em>wait callback</em></span> if such a callback
                    is called.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.valid"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.valid" title="Member function valid()">Member
            function <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.is_ready"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, and that result is
                    ready for retrieval, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.has_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_value" title="Member function has_value() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, that result is ready
                    for retrieval, and the result is a stored value, <code class="computeroutput"><span class="keyword">false</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.has_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_exception" title="Member function has_exception() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with an asynchronous result, that result is ready
                    for retrieval, and the result is a stored exception, <code class="computeroutput"><span class="keyword">false</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.get_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state()">Member
            function <code class="computeroutput"><span class="identifier">get_state</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Determine the state of the asynchronous result associated with
                    <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    if any.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with an asynchronous result. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a> if the asynchronous
                    result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is ready for retrieval,
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">waiting</span></code></a> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.promise"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">promise</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">promise</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>

  <span class="identifier">promise</span><span class="special">();</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">);</span>
  <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>

  <span class="comment">// Move support</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;;</span>
  <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">promise</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;;</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">promise</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="comment">// Result retrieval</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

  <span class="comment">// Set the value</span>
  <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">r</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">);</span>

  <span class="comment">// setting the result with deferred notification</span>
  <span class="comment">// void set_value_at_thread_exit(const R&amp; r); // NOT YET IMPLEMENTED</span>
  <span class="comment">// void set_value_at_thread_exit(see below); // NOT YET IMPLEMENTED</span>
  <span class="comment">// void set_exception_at_thread_exit(exception_ptr p); // NOT YET IMPLEMENTED</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> with no associated
                    result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.alloc_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.alloc_constructor" title="Allocator Constructor">Allocator
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">promise</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> with no associated
                    result using the allocator <code class="computeroutput"><span class="identifier">a</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Available only if BOOST_THREAD_FUTURE_USES_ALLOCATORS is defined.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a>, and transfers
                    ownership of the result associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the result associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated result. If there was already a result associated
                    with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    and that result was not <span class="emphasis"><em>ready</em></span>, sets any
                    futures associated with that result to <span class="emphasis"><em>ready</em></span>
                    with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                    exception as the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    If there was a result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, and that result is not
                    <span class="emphasis"><em>ready</em></span>, sets any futures associated with
                    that task to <span class="emphasis"><em>ready</em></span> with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> exception as
                    the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.get_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.get_future" title="Member Function get_future()">Member
            Function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    asynchronous result and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Returns a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> associated with
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code> if
                    the future associated with the task has already been retrieved.
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if any memory necessary
                    could not be allocated.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_value" title="Member Function set_value()">Member
            Function <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">set_value</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    asynchronous result and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Store the value <code class="computeroutput"><span class="identifier">r</span></code> in the asynchronous result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Any threads blocked waiting
                    for the asynchronous result are woken.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the asynchronous result are <span class="emphasis"><em>ready</em></span>
                    and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_value" title="Member function has_value() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_value</span><span class="special">()</span></code></a>
                    or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_value" title="Member function has_value() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_value</span><span class="special">()</span></code></a>
                    for those futures shall return <code class="computeroutput"><span class="keyword">true</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated. Any exception
                    thrown by the copy or move-constructor of <code class="computeroutput"><span class="identifier">R</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_exception" title="Member Function set_exception()">Member
            Function <code class="computeroutput"><span class="identifier">set_exception</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    asynchronous result and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Store the exception <code class="computeroutput"><span class="identifier">e</span></code> in the asynchronous result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Any threads blocked waiting
                    for the asynchronous result are woken.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the asynchronous result are <span class="emphasis"><em>ready</em></span>
                    and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    for those futures shall return <code class="computeroutput"><span class="keyword">true</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_wait_callback"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_wait_callback" title="Member Function set_wait_callback()">Member
            Function <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    The expression <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> where <code class="computeroutput"><span class="identifier">t</span></code>
                    is a lvalue of type <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> shall be well-formed.
                    Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    shall have the same effect as invoking <code class="computeroutput"><span class="identifier">f</span></code>
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Store a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    with the asynchronous result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> as a <span class="emphasis"><em>wait callback</em></span>.
                    This will replace any existing wait callback store alongside
                    that result. If a thread subsequently calls one of the wait functions
                    on a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> associated
                    with this result, and the result is not <span class="emphasis"><em>ready</em></span>,
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span></code>
                    shall be invoked.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if memory cannot
                    be allocated for the required storage.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.packaged_task"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">packaged_task</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span>
  <span class="comment">// , class... ArgTypes // NOT YET IMPLEMENTED</span>
<span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">packaged_task</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">R</span> <span class="identifier">result_type</span><span class="special">;</span>

  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&amp;);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span><span class="special">&amp;);//</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

  <span class="comment">// construction and destruction</span>
  <span class="identifier">packaged_task</span><span class="special">()</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)());</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="special">~</span><span class="identifier">packaged_task</span><span class="special">()</span>
  <span class="special">{}</span>

  <span class="comment">// move support</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">noexcept</span><span class="special">;</span>

  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">noexcept</span><span class="special">;</span>
  <span class="comment">// result retrieval</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

  <span class="comment">// execution</span>
  <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()();</span>
  <span class="comment">// void operator()(ArgTypes... );  // NOT YET IMPLEMENTED</span>
  <span class="comment">// void make_ready_at_thread_exit(ArgTypes...); // NOT YET IMPLEMENTED</span>

  <span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.task_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.task_constructor" title="Task Constructor">Task
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)());</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span><span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">()</span></code>
                    is a valid expression with a return type convertible to <code class="computeroutput"><span class="identifier">R</span></code>. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code> shall behave the same as
                    invoking <code class="computeroutput"><span class="identifier">f</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> with
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)</span></code>
                    stored as the associated task.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exceptions thrown by the copy (or move) constructor of <code class="computeroutput"><span class="identifier">f</span></code>. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
                    if memory for the internal data structures could not be allocated.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The R(*f)()) overload to allow passing a function without needing
                    to use <code class="computeroutput"><span class="special">&amp;</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.alloc_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.alloc_constructor" title="Allocator Constructor">Allocator
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)());</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">()</span></code>
                    is a valid expression with a return type convertible to <code class="computeroutput"><span class="identifier">R</span></code>. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code> shall behave the same as
                    invoking <code class="computeroutput"><span class="identifier">f</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> with
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)</span></code>
                    stored as the associated task using the allocator <code class="computeroutput"><span class="identifier">a</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exceptions thrown by the copy (or move) constructor of <code class="computeroutput"><span class="identifier">f</span></code>. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
                    if memory for the internal data structures could not be allocated.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Available only if BOOST_THREAD_FUTURE_USES_ALLOCATORS is defined.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The R(*f)()) overload to allow passing a function without needing
                    to use <code class="computeroutput"><span class="special">&amp;</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>, and transfers
                    ownership of the task associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated task.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the task associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated task. If there was already a task associated
                    with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    and that task has not been invoked, sets any futures associated
                    with that task to <span class="emphasis"><em>ready</em></span> with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> exception as
                    the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">packaged_task</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    If there was a task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, and that task has not been
                    invoked, sets any futures associated with that task to <span class="emphasis"><em>ready</em></span>
                    with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                    exception as the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.get_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.get_future" title="Member Function get_future()">Member
            Function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Returns a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> associated with
                    the result of the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code> if
                    the future associated with the task has already been retrieved.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.call_operator"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.call_operator" title="Member Function operator()()">Member
            Function <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invoke the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and store the result in the
                    corresponding future. If the task returns normally, the return
                    value is stored as the asynchronous result, otherwise the exception
                    thrown is stored. Any threads blocked waiting for the asynchronous
                    result associated with this task are woken.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the asynchronous result are <span class="emphasis"><em>ready</em></span>
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_started</span></code> if the
                    task has already been invoked.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.reset"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.reset" title="Member Function reset()">Member
            Function <code class="computeroutput"><span class="identifier">reset</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Reset the state of the packaged_task so that it can be called
                    again.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.set_wait_callback"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.set_wait_callback" title="Member Function set_wait_callback() EXTENSION">Member
            Function <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    The expression <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> where <code class="computeroutput"><span class="identifier">t</span></code>
                    is a lvalue of type <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> shall
                    be well-formed. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    shall have the same effect as invoking <code class="computeroutput"><span class="identifier">f</span></code>
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Store a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    with the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> as a <span class="emphasis"><em>wait callback</em></span>.
                    This will replace any existing wait callback store alongside
                    that task. If a thread subsequently calls one of the wait functions
                    on a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> associated
                    with this task, and the result of the task is not <span class="emphasis"><em>ready</em></span>,
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span></code>
                    shall be invoked.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.decay_copy"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.decay_copy" title="Non-member function decay_copy()">Non-member
          function <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.async"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.async" title="Non-member function async()">Non-member
          function <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<p>
            The function template async provides a mechanism to launch a function
            potentially in a new thread and provides the result of the function in
            a future object with which it shares a shared state.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span><span class="special">,</span>
              <span class="identifier">F</span><span class="special">)</span></code>
              is NOT YET IMPLEMENTED!
            </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd>
<p>
</p>
<pre class="programlisting"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span>
</pre>
<p>
                </p>
<p>
                  shall be a valid expression.
                </p>
</dd>
<dt><span class="term">Effects</span></dt>
<dd>
<p>
                  The first function behaves the same as a call to the second function
                  with a policy argument of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                  and the same arguments for <code class="computeroutput"><span class="identifier">F</span></code>.
                  The second function creates a shared state that is associated with
                  the returned future object.
                </p>
<p>
                  The further behavior of the second function depends on the policy
                  argument as follows (if more than one of these conditions applies,
                  the implementation may choose any of the corresponding policies):
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code> is non-zero - calls <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span></code>
                  as if in a new thread of execution represented by a thread object
                  with the calls to <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code> being evaluated in the thread
                  that called <code class="computeroutput"><span class="identifier">async</span></code>.
                  Any return value is stored as the result in the shared state. Any
                  exception propagated from the execution of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span></code> is stored as the exceptional
                  result in the shared state. The thread object is stored in the
                  shared state and affects the behavior of any asynchronous return
                  objects that reference that state.
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code> is non-zero - Stores
                  <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code>
                  in the shared state. This copy of <code class="computeroutput"><span class="identifier">f</span></code>
                  constitute a deferred function. Invocation of the deferred function
                  evaluates <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">)()</span></code> where <code class="computeroutput"><span class="identifier">g</span></code>
                  is the stored value of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code>. The shared state is not made
                  ready until the function has completed. The first call to a non-timed
                  waiting function on an asynchronous return object referring to
                  this shared state shall invoke the deferred function in the thread
                  that called the waiting function. Once evaluation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">)()</span></code>
                  begins, the function is no longer considered deferred. (Note: If
                  this policy is specified together with other policies, such as
                  when using a policy value of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>,
                  implementations should defer invocation or the selection of the
                  policy when no more concurrency can be effectively exploited.)
                </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  An object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span></code>
                  that refers to the shared state created by this call to <code class="computeroutput"><span class="identifier">async</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd>
<p>
                  Regardless of the provided policy argument,
                </p>
<p>
                  - the invocation of <code class="computeroutput"><span class="identifier">async</span></code>
                  synchronizes with the invocation of <code class="computeroutput"><span class="identifier">f</span></code>.
                  (Note: This statement applies even when the corresponding future
                  object is moved to another thread.); and
                </p>
<p>
                  - the completion of the function <code class="computeroutput"><span class="identifier">f</span></code>
                  is sequenced before the shared state is made ready. (Note: <code class="computeroutput"><span class="identifier">f</span></code> might not be called at all,
                  so its completion might never happen.)
                </p>
<p>
                  If the implementation chooses the <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  policy,
                </p>
<p>
                  - a call to a waiting function on an asynchronous return object
                  that shares the shared state created by this async call shall block
                  until the associated thread has completed, as if joined;
                </p>
<p>
                  - the associated thread completion synchronizes with the return
                  from the first function that successfully detects the ready status
                  of the shared state or with the return from the last function that
                  releases the shared state, whichever happens first.
                </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">system_error</span></code> if
                  policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the implementation is unable to start a new thread.
                </p></dd>
<dt><span class="term">Error conditions:</span></dt>
<dd><p>
                  - <code class="computeroutput"><span class="identifier">resource_unavailable_try_again</span></code>
                  - if policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the system is unable to start a new thread.
                </p></dd>
<dt><span class="term">Remarks:</span></dt>
<dd><p>
                  The first signature shall not participate in overload resolution
                  if decay&lt;F&gt;::type is boost::launch.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.wait_for_any"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_any" title="Non-member function wait_for_any()">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="identifier">Iterator</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F5</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">,</span><span class="identifier">F5</span><span class="special">&amp;</span> <span class="identifier">f5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  The types <code class="computeroutput"><span class="identifier">Fn</span></code> shall
                  be specializations of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, and <code class="computeroutput"><span class="identifier">Iterator</span></code> shall be a forward iterator
                  with a <code class="computeroutput"><span class="identifier">value_type</span></code>
                  which is a specialization of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Waits until at least one of the specified futures is <span class="emphasis"><em>ready</em></span>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  The range-based overload returns an <code class="computeroutput"><span class="identifier">Iterator</span></code>
                  identifying the first future in the range that was detected as
                  <span class="emphasis"><em>ready</em></span>. The remaining overloads return the
                  zero-based index of the first future that was detected as <span class="emphasis"><em>ready</em></span>
                  (first parameter =&gt; 0, second parameter =&gt; 1, etc.).
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the current
                  thread is interrupted. Any exception thrown by the <span class="emphasis"><em>wait
                  callback</em></span> associated with any of the futures being waited
                  for. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if memory could not
                  be allocated for the internal wait structures.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code>
                  is an <span class="emphasis"><em>interruption point</em></span>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.wait_for_all"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_all" title="Non-member function wait_for_all()">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F5</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">,</span><span class="identifier">F5</span><span class="special">&amp;</span> <span class="identifier">f5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  The types <code class="computeroutput"><span class="identifier">Fn</span></code> shall
                  be specializations of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, and <code class="computeroutput"><span class="identifier">Iterator</span></code> shall be a forward iterator
                  with a <code class="computeroutput"><span class="identifier">value_type</span></code>
                  which is a specialization of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Waits until all of the specified futures are <span class="emphasis"><em>ready</em></span>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by a call to <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> on the specified futures.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code>
                  is an <span class="emphasis"><em>interruption point</em></span>.
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 -11 Anthony Williams<br>Copyright &#169; 2011 -12 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="thread_management.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
